<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>SRFI 18: Multithreading support</title>
  </head>

  <body>

<H1>Title</H1>

Multithreading support

<H1>Author</H1>

Marc Feeley

<H1>Status</H1>

This SRFI is currently in ``draft'' status.  To see an explanation of each status that a SRFI can hold, see <A HREF="http://srfi.schemers.org/srfi-process.html">here</A>.
It will remain in draft status until 2000/04/06, or as amended.
To provide input on this SRFI, please <CODE><A
HREF="mailto:srfi-18@srfi.schemers.org">mail to
&lt;srfi-18@srfi.schemers.org&gt;</A></CODE>.  See <A HREF=../srfi-list-subscribe.html>instructions here</A> to subscribe to the list.  You can access previous messages via <A HREF=mail-archive/maillist.html>the archive of the mailing list</A>.
<P><UL>
<LI>Received: 2000/02/04</LI>
<LI>Revised: 2000/04/07</LI>
<LI>Draft: 2000/02/07-2000/04/06</LI>
</UL>


<H1>Abstract</H1>

<P>
This SRFI defines the following multithreading datatypes for Scheme
<UL>
<LI>Thread
<!--
<LI>Thread group
-->
<LI>Mutex
<LI>Condition variable
<LI>Time
</UL>
</P>

<P>
It also defines a mechanism to handle exceptions and some
multithreading exception datatypes.
</P>

<H1>Issues</H1>

<UL>

<LI>Should there be some kind of priority aging as in most UNIX
systems (i.e. the priority of a thread gradually increases with time
as long as it is runnable and drops back when it runs), or a priority
decay as in QNX (i.e. the priority of a thread drops by one if it has
run for more than it's quantum without blocking, see <A
HREF="http://www.qnx.com/literature/qnx_sysarch/microkernel.html#SCHEDULING">http://www.qnx.com/literature/qnx_sysarch/microkernel.html#SCHEDULING</A>),
or something else?

<LI>Should the datatypes be distinct from all other Scheme datatypes,
i.e.  if any of the predicates listed in Section 3.2 of the R5RS is
true of <CODE><I>obj</I></CODE>, then <CODE>thread?</CODE>,
<CODE>mutex?</CODE>, etc are false of <CODE><I>obj</I></CODE>.

<LI>Should other features of the Java thread model be added, such as:

  <OL>

  <LI>Thread groups.  This might be useful to implement a debugger, or
      to encapsulate the threads assigned to different tasks or users.

  <LI>Thread interrupts.  The mechanism can be implemented at the
      user-level with a flag and mutex, but should all threads have
      this mechanism?

  <LI>Thread local storage.  I think dynamically scoped variables
      would be a better interface.

</OL>

</UL>

<H1>Rationale</H1>

<P>
Multithreading is a paradigm that is well suited for building complex
systems such as: servers, GUIs, and high-level operating systems.  All
thread systems, including the one proposed here, offer mechanisms for
creating new threads of execution and for synchronizing them.
Mechanisms for controlling access privileges for various operations
are also usually provided by thread systems.  This SRFI does not
include such access control mechanisms because it aims to provide
basic mechanisms on top of which higher-level abstractions can be
built.
</P>

<P>
This SRFI also specifies a datatype for time which is useful on it's
own but is also required for specifying absolute synchronization
timeouts.  Mechanisms to handle exceptions and some multithreading
exception datatypes are also provided because exception are closely
tied to the multithreading model.
</P>

<H1>Specification</H1>

<P>
The thread system provides the following data types:
<UL>
<LI>Thread (a virtual processor which shares address space with all other threads)
<!--
<LI>Thread group (a collection of threads)
-->
<LI>Mutex (a mutual exclusion device, also known as a lock)
<LI>Condition variable (a queue of blocked threads)
<LI>Time (an absolute point on the time line)
</UL>
</P>

<P>
Some multithreading exception datatypes are also specified, and a
general mechanism for handling exceptions.
</P>

<H4>Thread</H4>

<P>
A "running" thread is a thread that is currently executing (there
could be more than one on a multiprocessor machine).  A "runnable"
thread is a thread that is not running and that is not blocked waiting
for a mutex to unlock, an I/O operation to become possible, etc.  Each
thread has a "priority", which is an exact integer (where higher
numerical values mean higher priority), and a "quantum", which is a
non-negative real representing a duration in seconds.
</P>

<H4>Mutex</H4>

<P>
A mutex can be in one of three states: unlocked, locked, and
abandoned.  When a mutex is in the locked state, it's "owner" is the
thread that locked it (or the thread that was assigned to it when the
mutex was created, see <CODE>make-mutex</CODE>).  An abandoned mutex
is a previously locked mutex whose owner has terminated.  Mutexes are
not recursive (i.e. if a thread tries to lock a mutex that is
currently locked the thread will block even if it is the owner of the
mutex).
</P>

<H4>Condition variable</H4>

<P>
A condition variable represents a set of blocked threads.  These
blocked threads are waiting for a certain condition to become true.
When a thread modifies some program state that might make the
condition true, the thread unblocks some number of threads (depending
on the primitive used) so they can check the value of the condition.
This allows complex forms of interthread synchronization to be
expressed more conveniently than with mutexes alone.
</P>

<H4>Priority and fairness</H4>

<P>
An implementation of Scheme conforming to this SRFI is required to
obey, at least, the following fairness constraints.
</P>

<P>
Let P be the highest priority of the set of runnable threads.  The
scheduler will pick the priority P thread that has become runnable for
the longest time and resume it's execution.  When an amount of time
equal to the thread's quantum has elapsed and the thread has not
blocked or terminated yet, the scheduler will preempt the thread and
pick the next thread to schedule.  A thread's quantum is thus an
indication of the rate of progress of the thread relative to the other
threads of the same priority.  Moreover, the preemption timer's
resolution may cause a certain deviation from the quantum, so a
thread's quantum should only be viewed as an approximation.
</P>

<P>
When two threads A and B are blocked on a given mutex or condition
variable, and A blocked before B, then
<OL>
<LI>if A's priority is not less than B's priority, A will wakeup before B
<LI>otherwise, A will wakeup before or after B.
</OL>
</P>

<H4>Memory coherency and lack of atomicity</H4>

<P>
Read and write operations on the store (such as reading and writing a
variable, an element of a vector or a string) are not required to be
atomic.  It is an error for a thread to write a location in the store
while some other thread reads or writes that same location.  It is the
responsibility of the application to avoid write/read and write/write
races through appropriate uses of the synchronization primitives.
</P>

<H4>Primordial thread</H4>

<P>
The execution of a program is initially under the control of a single
thread known as the "primordial thread".  The primordial thread has an
unspecified priority, quantum and name.  The binding of the exception
handler is unspecified.  The program's execution terminates when the
primordial thread terminates (normally or not).
</P>

<H4>Continuations</H4>

<P>
A thread can call a continuation captured with a call to
<CODE>call-with-current-continuation</CODE> by that thread.  A thread
can also call a continuation captured by another thread as long as the
call and the continuation are not in the scope of an
<CODE>dynamic-wind</CODE>.
</P>

<P>
Rationale: The semantics of <CODE>dynamic-wind</CODE> only make
sense in a single threaded world because it is possible to give
meaning to the concept "control is currently inside the scope of a
particular <CODE>dynamic-wind</CODE>".  In a multithreaded world,
there are more than one threads of control so it is not clear when a
particular <CODE>dynamic-wind</CODE> scope is being exited or
reentered.
</P>

<H4>Time objects and timeouts</H4>

<P>
A time object represents a point on the time line.  It's resolution
is implementation dependent.
</P>

<P>
All synchronization primitives which take a timeout parameter accept
three types of values as a timeout, with the following meaning:
<UL>
<LI>a time object represents an absolute point in time
<LI>an exact or inexact real represents a relative time in seconds from
the moment the primitive was called
<LI><CODE>#f</CODE> means that there is no timeout
</UL>
</P>

<H4>Primitives and exceptions</H4>

<P>
When one of the primitives defined in this SRFI raises an exception,
the exception handler is called with the same continuation as the
primitive (i.e. it is a tail call to the exception handler).
</P>

<H4>Procedures</H4>

<DL>

<DT><PRE>
(current-thread)                                      ;procedure
</PRE><DD>

    Returns the current thread.

<PRE>
        (eq? (current-thread) (current-thread))  ==>  #t
</PRE>

<DT><PRE>
(thread? <I>obj</I>)                                         ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is a thread,
    otherwise returns <CODE>#f</CODE>.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true of
    <CODE><I>obj</I></CODE>, then <CODE>thread?</CODE> is false of
    <CODE><I>obj</I></CODE>.
-->

<PRE>
        (thread? (current-thread))  ==>  #t
        (thread? 'foo)              ==>  #f
</PRE>

<DT><PRE>
<!--
(make-thread <I>thunk</I> [<I>name</I> [<I>thread-group</I>]])             ;procedure
-->
(make-thread <I>thunk</I> [<I>name</I>])                            ;procedure
</PRE><DD>

    Returns a newly allocated thread.  This thread is not
    automatically made runnable (the procedure
    <CODE>thread-start!</CODE> must be used for this).  A thread has
    the following fields: priority, quantum, name, end-result,
    end-exception, and a list of mutexes it owns.  The thread's
    execution consists of a call to <I>thunk</I> with a continuation
    that causes the (then) current thread to store the result in it's
    end-result field, abandon all mutexes it owns, and finally
    terminate.  The optional <CODE><I>name</I></CODE> is an arbitrary
    Scheme object which identifies the thread (useful for debugging);
    it defaults to an unspecified value.
<!--
    The optional <CODE><I>thread-group</I></CODE> indicates which
    thread group this thread belongs to; it defaults to the thread
    group of the current thread.
-->
    The priority and quantum of the thread are set to the same value
    as the current thread.  The thread also inherits the dynamic
    environment from the current thread (i.e. procedures which access
    the dynamic environment, such as
    <CODE>(current-input-port)</CODE>, obtain the binding in effect
    when <CODE>make-thread</CODE> was called).  Moreover, in this
    dynamic environment the exception handler is bound to the "initial
    exception handler" which is a unary procedure which causes the
    (then) current thread to store in it's end-exception field an
    "uncaught exception" object whose "reason" is the argument of the
    handler, abandon all mutexes it owns, and finally terminate.

<PRE>
        (make-thread (lambda () (write 'hello)))  ==>  <I>a thread</I>
</PRE>

<DT><PRE>
(thread-name <I>thread</I>)                                  ;procedure
</PRE><DD>

    Returns the name of the <CODE><I>thread</I></CODE>.

<PRE>
        (thread-name (make-thread (lambda () #f) 'foo))  ==>  foo
</PRE>

<DT><PRE>
(thread-priority <I>thread</I>)                              ;procedure
</PRE><DD>

    Returns an exact integer representing the priority of the
    <CODE><I>thread</I></CODE>.

<PRE>
        (thread-priority (current-thread))  ==>  1
</PRE>

<DT><PRE>
(thread-priority-set! <I>thread</I> <I>priority</I>)                ;procedure
</PRE><DD>

    Changes the priority of the <CODE><I>thread</I></CODE> to
    <CODE><I>priority</I></CODE>.  The <CODE><I>priority</I></CODE>
    must be an exact integer in the range
    <CODE>(thread-min-priority)</CODE> to
    <CODE>(thread-max-priority)</CODE> (inclusive).  If
    <CODE><I>thread</I></CODE> is running, the scheduler may wait
    until the thread blocks or is preempted before reconsidering
    scheduling order.  <CODE>thread-priority-set!</CODE> returns an
    unspecified value.

<PRE>
        (thread-priority-set! (current-thread) 3)  ==>  <I>unspecified</I>
</PRE>

<DT><PRE>
(thread-min-priority)                                 ;procedure
</PRE><DD>

    Returns an exact integer representing the lowest priority that a
    thread can have.

<PRE>
        (thread-min-priority)  ==>  -128
</PRE>

<DT><PRE>
(thread-max-priority)                                 ;procedure
</PRE><DD>

    Returns an exact integer representing the highest priority that a
    thread can have.

<PRE>
        (thread-max-priority)  ==>  127
</PRE>

<DT><PRE>
(thread-quantum <I>thread</I>)                               ;procedure
</PRE><DD>

    Returns a real number which corresponds to the quantum of the
    <CODE><I>thread</I></CODE>.

<PRE>
        (thread-quantum (current-thread))  ==>  0.1
</PRE>

<DT><PRE>
(thread-quantum-set! <I>thread</I> <I>quantum</I>)                  ;procedure
</PRE><DD>

    Changes the quantum of the <CODE><I>thread</I></CODE> to
    <CODE><I>quantum</I></CODE>.  The <CODE><I>quantum</I></CODE> must
    be an exact or inexact non-negative real.  A value of zero selects
    the smallest quantum supported by the implementation.  If
    <CODE><I>thread</I></CODE> is running, the scheduler may wait
    until the thread blocks or is preempted before reconsidering
    scheduling order.  <CODE>thread-quantum-set!</CODE> returns an
    unspecified value.

<PRE>
        (thread-quantum-set! (current-thread) 2)  ==>  <I>unspecified</I>
</PRE>

<DT><PRE>
(thread-start! <I>thread</I>)                                 ;procedure
</PRE><DD>

    Makes <CODE><I>thread</I></CODE> runnable.  A "started thread
    exception" is raised if the <CODE><I>thread</I></CODE> was
    previously started or terminated.  <CODE>thread-start!</CODE>
    returns an unspecified value.

<PRE>
        (let ((t (make-thread (lambda () (write 'a)))))
          (thread-start! t)
          (write 'b)
          (thread-join! t))             ==>  <I>unspecified</I>
                                             <I>after writing</I> ab <I>or</I> ba
</PRE>

    NOTE: It is useful to separate thread creation and thread
    activation to avoid the race condition that would occur if the
    created thread tries to examine a table in which the current
    thread stores the created thread.  See the last example of
    <CODE>thread-terminate!</CODE> which contains mutually recursive
    threads.

<DT><PRE>
(thread-yield!)                                        ;procedure
</PRE><DD>

    The current thread is preempted as if it's quantum had expired.
    All runnable threads with a priority no lower than the current
    thread will run before the current thread runs again.
    <CODE>thread-yield!</CODE> returns an unspecified value.

<PRE>
        (let loop ()
          (if (mutex-lock! m 0) ; try to lock but don't block
              (begin
                (display "locked mutex m")
                (mutex-unlock! m))
              (begin
                (do-something-else)
                (thread-yield!) ; be friendly
                (loop))))
</PRE>

<DT><PRE>
(thread-sleep! <I>timeout</I>)                                ;procedure
</PRE><DD>

    The current thread blocks.  It will become runnable again when the
    timeout is reached.  It is an error for <CODE><I>timeout</I></CODE>
    to be <CODE>#f</CODE>.  <CODE>thread-sleep!</CODE> returns an
    unspecified value.

<PRE>
        ; a clock with a gradual drift:
        (let loop ((x 1))
          (thread-sleep! 1)
          (write x)
          (loop (+ x 1)))

        ; a clock with no drift:
        (let ((start (time->seconds (current-time)))
          (let loop ((x 1))
            (thread-sleep! (seconds->time (+ x start)))
            (write x)
            (loop (+ x 1))))
</PRE>

<DT><PRE>
(thread-terminate! <I>thread</I>)                             ;procedure
</PRE><DD>

    Causes an abnormal termination of the <CODE><I>thread</I></CODE>.
    If <CODE><I>thread</I></CODE> is not running or it is the current
    thread, it is terminated immediately, otherwise the scheduler may
    wait until the thread blocks or is preempted before terminating
    it.  All mutexes owned by the <CODE><I>thread</I></CODE> are
    abandoned and a "terminated thread exception" object is stored in
    the <CODE><I>thread</I></CODE>'s end-exception field.  It is not
    an error if <CODE><I>thread</I></CODE> is already terminated,
    blocked, or not started.  <CODE>thread-terminate!</CODE> returns
    an unspecified value.

<PRE>
        (thread-terminate! (current-thread))  ==>  <I>does not return</I>

        (define (amb thunk1 thunk2)
          (let ((result #f)
                (result-mutex (make-mutex))
                (done (make-mutex (current-thread))))
            (letrec ((child1
                      (make-thread
                        (lambda ()
                          (let ((x (thunk1)))
                            (mutex-lock! result-mutex)
                            (set! result x)
                            (thread-terminate! child2)
                            (mutex-unlock! done)))))
                     (child2
                      (make-thread
                        (lambda ()
                          (let ((x (thunk2)))
                            (mutex-lock! result-mutex)
                            (set! result x)
                            (thread-terminate! child1)
                            (mutex-unlock! done))))))
              (thread-start! child1)
              (thread-start! child2)
              (mutex-lock! done)
              (mutex-unlock! done) ; avoid space leak
              (mutex-unlock! result-mutex) ; avoid space leak
              result)))
</PRE>

    NOTE: This operation must be used carefully because it terminates
    a thread abruptly and it is impossible for that thread to perform
    any kind of cleanup.  This may be a problem if the thread is in
    the middle of a critical section where some structure has been put
    in an inconsistent state.  However, another thread attempting to
    enter this critical section (by calling <CODE>mutex-lock!</CODE>
    on the appropriate mutex) will raise an "abandoned mutex
    exception" because that mutex was abandoned.  This helps avoid
    observing an inconsistent state.

<DT><PRE>
(thread-join! thread [<I>timeout</I> [<I>timeout-val</I>]])         ;procedure
</PRE><DD>

    The current thread blocks until the <CODE><I>thread</I></CODE>
    terminates (normally or not) or until the timeout is reached if
    <CODE><I>timeout</I></CODE> is supplied.  If the timeout is
    reached, <CODE><I>timeout-val</I></CODE> is returned if it is
    supplied, otherwise a "join timeout exception" is raised.  If the
    <CODE><I>thread</I></CODE> terminated normally, the content of the
    end-result field is returned, otherwise the content of the
    end-exception field is raised.

<PRE>
        (let ((t (make-thread (lambda () (expt 2 100)))))
          (thread-start! t)
          (do-something-else)
          (thread-join! t))  ==>  1267650600228229401496703205376

        (let ((t (make-thread (lambda () (raise 123)))))
          (thread-start! t)
          (do-something-else)
          (with-exception-handler
            (lambda (exc)
              (if (uncaught-exception? exc)
                  (* 10 (uncaught-exception-reason exc))
                  'foo))
            (lambda ()
              (thread-join! t))))  ==>  1230

        (define thread-alive?
          (let ((unique (list 'unique)))
            (lambda (thread)
              ; note: this procedure raises an exception if
              ; the thread terminated abnormally
              (eq? (thread-join! thread 0 unique) unique))))
</PRE>

<DT><PRE>
(mutex? <I>obj</I>)                                          ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is a mutex,
    otherwise returns <CODE>#f</CODE>.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true
    of <CODE><I>obj</I></CODE>, then <CODE>mutex?</CODE> is false of
    <CODE><I>obj</I></CODE>.
-->

<PRE>
        (mutex? (make-mutex))  ==>  #t
        (mutex? 'foo)          ==>  #f
</PRE>

<DT><PRE>
(make-mutex [<I>thread</I> [<I>name</I>]])                          ;procedure
</PRE><DD>

    Returns a newly allocated mutex.  If <CODE><I>thread</I></CODE> is
    not supplied or is <CODE>#f</CODE> the mutex is in an unlocked
    state, if the <CODE><I>thread</I></CODE> is terminated the mutex
    is in an abandoned state, otherwise the mutex is in a locked state
    and is owned by the <CODE><I>thread</I></CODE>.  The optional
    <CODE><I>name</I></CODE> is an arbitrary Scheme object which
    identifies the mutex (useful for debugging); it defaults to an
    unspecified value.

<PRE>
        (make-mutex)                   ==>  <I>an unlocked mutex</I>
        (make-mutex #f)                ==>  <I>an unlocked mutex</I>
        (make-mutex #f 'foo)           ==>  <I>an unlocked mutex with name</I> foo
        (make-mutex (current-thread))  ==>  <I>a locked mutex</I>
</PRE>

<DT><PRE>
(mutex-owner <I>mutex</I>)                                   ;procedure
</PRE><DD>

    Returns information about the state of the <CODE><I>mutex</I></CODE>.  The
    possible results are:

       <UL>

       <LI><STRONG>thread T</STRONG>:
           the <CODE><I>mutex</I></CODE> is locked (thread T is
           the owner of the <CODE><I>mutex</I></CODE>)

       <LI><STRONG><CODE>#f</CODE></STRONG>:
           the <CODE><I>mutex</I></CODE> is unlocked (it has no owner)

       <LI><STRONG><CODE>#t</CODE></STRONG>:
           the <CODE><I>mutex</I></CODE> is abandoned (the thread that
           owned the <CODE><I>mutex</I></CODE> is currently
           terminated)

       </UL>

<PRE>
        (mutex-owner (make-mutex))  ==>  #f

        (define (thread-alive? thread)
          (let* ((mutex (make-mutex thread))
                 (result (eq? (mutex-owner mutex) thread)))
            (mutex-unlock! mutex) ; avoid space leak
            result))
</PRE>

<DT><PRE>
(mutex-name <I>mutex</I>)                                    ;procedure
</PRE><DD>

    Returns the name of the <CODE><I>mutex</I></CODE>.

<PRE>
        (mutex-name (make-mutex #f 'foo))  ==>  foo
</PRE>

<DT><PRE>
(mutex-lock! <I>mutex</I> [<I>timeout</I>])                         ;procedure
</PRE><DD>

    If the <CODE><I>mutex</I></CODE> is currently locked, the current
    thread is suspended until the <CODE><I>mutex</I></CODE> is
    unlocked or abandoned, or until the timeout is reached if
    <CODE><I>timeout</I></CODE> is supplied.  If the timeout is
    reached, <CODE><I>#f</I></CODE> is returned.  Otherwise the
    current thread locks the <CODE><I>mutex</I></CODE> by becoming
    it's owner.  An "abandoned mutex exception" is raised (after
    locking the <CODE><I>mutex</I></CODE>) if the
    <CODE><I>mutex</I></CODE> was abandoned, otherwise
    <CODE>mutex-lock!</CODE> returns <CODE>#t</CODE>.  It is not an
    error if the <CODE><I>mutex</I></CODE> is owned by the current
    thread (but the current thread will block).

<PRE>
        ; an alternative implementation of thread-sleep!
        (define (sleep! timeout)
          (let ((m (make-mutex (current-thread))))
            (mutex-lock! m timeout)
            (mutex-unlock! m))) ; avoid space leak
</PRE>

<DT><PRE>
(mutex-unlock! <I>mutex</I>)                                 ;procedure
</PRE><DD>

    Unlocks the <CODE><I>mutex</I></CODE>.  It is not an error to
    unlock an unlocked mutex, an abandoned mutex, and a mutex that is
    owned by a thread other than the current thread.  If there are
    threads waiting for this <CODE><I>mutex</I></CODE> to unlock, a
    thread is selected according to the fairness constraints specified
    above, it is made runnable and is made the owner of the lock.
    <CODE>mutex-unlock!</CODE> returns an unspecified value.

<PRE>
        (define next-serial-number!
          (let ((counter 0)
                (mutex (make-mutex)))
            (lambda ()
              (mutex-lock! mutex)
              (let ((result (+ counter 1)))
                (set! counter result)
                (mutex-unlock! mutex)
                result))))
</PRE>

<DT><PRE>
(condition-variable? <I>obj</I>)                             ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is a condition
    variable, otherwise returns <CODE>#f</CODE>.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true
    of <CODE><I>obj</I></CODE>, then <CODE>condition-variable?</CODE>
    is false of <CODE><I>obj</I></CODE>.
-->

<PRE>
        (condition-variable? (make-condition-variable))  ==>  #t
        (condition-variable? 'foo)                       ==>  #f
</PRE>

<DT><PRE>
(make-condition-variable [<I>name</I>])                      ;procedure
</PRE><DD>

    Returns a newly allocated empty condition variable.  The optional
    <CODE><I>name</I></CODE> is an arbitrary Scheme object which
    identifies the condition variable (useful for debugging); it
    defaults to an unspecified value.

<PRE>
        (make-condition-variable)  ==>  <I>an empty condition variable</I>

        (define (make-semaphore n)
          (vector n (make-mutex) (make-condition-variable)))
</PRE>

<DT><PRE>
(condition-variable-wait! <I>condition-variable</I> <I>mutex</I> [<I>timeout</I>])  ;procedure
</PRE><DD>

    The current thread is blocked and added to the
    <CODE><I>condition-variable</I></CODE>, then the
    <CODE><I>mutex</I></CODE> is unlocked.  The thread remains blocked
    until a call to <CODE>condition-variable-signal!</CODE> or
    <CODE>condition-variable-broadcast!</CODE> wakes up this thread
    (see below), or until the timeout is reached if
    <CODE><I>timeout</I></CODE> is supplied.  If the timeout is
    reached, <CODE><I>#f</I></CODE> is returned, otherwise the
    <CODE><I>mutex</I></CODE> is locked (this raises an "abandoned
    mutex exception" if the <CODE><I>mutex</I></CODE> is abandoned)
    and <CODE><I>#t</I></CODE> is returned.

<PRE>
        (define (semaphore-wait! sema)
          (mutex-lock! (vector-ref sema 1))
          (let loop ()
            (let ((n (vector-ref sema 0)))
              (if (> n 0)
                  (begin
                    (vector-set! sema 0 (- n 1))
                    (mutex-unlock! (vector-ref sema 1)))
                  (begin
                    (condition-variable-wait!
                      (vector-ref sema 2)
                      (vector-ref sema 1))
                    (loop)))))
</PRE>

<DT><PRE>
(condition-variable-signal! <I>condition-variable</I>)       ;procedure
</PRE><DD>

    If there are threads blocked on the
    <CODE><I>condition-variable</I></CODE>, a thread is selected
    according to the fairness constraints specified above and is made
    runnable.  <CODE>condition-variable-signal!</CODE> returns an
    unspecified value.

<PRE>
        (define (semaphore-signal! sema)
          (mutex-lock! (vector-ref sema 1))
          (let ((n (+ (vector-ref sema 0) 1)))
            (vector-set! sema 0 n)
            (mutex-unlock! (vector-ref sema 1))
            (if (> n 0)
                (condition-variable-signal! (vector-ref sema 2)))))
</PRE>

<DT><PRE>
(condition-variable-broadcast! <I>condition-variable</I>)    ;procedure
</PRE><DD>

    Extracts from the <CODE><I>condition-variable</I></CODE> all the
    threads that are blocked and makes them runnable in an order
    compatible with the fairness constraints specified above.
    <CODE>condition-variable-broadcast!</CODE> returns an unspecified
    value.

<PRE>
        (define (semaphore-signal-by! sema increment)
          (mutex-lock! (vector-ref sema 1))
          (let ((n (+ (vector-ref sema 0) increment)))
            (vector-set! sema 0 n)
            (mutex-unlock! (vector-ref sema 1))
            (if (> n 0)
                (condition-variable-broadcast! (vector-ref sema 2)))))
</PRE>

<DT><PRE>
(current-time)                                        ;procedure
</PRE><DD>

    Returns the time object corresponding to the current time.

<PRE>
        (current-time)  ==>  <I>a time object</I>
</PRE>

<DT><PRE>
(time? <I>obj</I>)                                           ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is a time object,
    otherwise returns <CODE>#f</CODE>.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true of
    <CODE><I>obj</I></CODE>, then <CODE>time?</CODE> is false of
    <CODE><I>obj</I></CODE>.
-->

<PRE>
        (time? (current-time))  ==>  #t
        (time? 123)             ==>  #f
</PRE>

<DT><PRE>
(time->seconds <I>time</I>)                                  ;procedure
</PRE><DD>

    Converts the time object <CODE><I>time</I></CODE> into an exact or
    inexact real number representing the number of seconds elapsed
    since some implementation dependent point in time.

<PRE>
        (time->seconds (current-time))  ==>  955039784.928075
</PRE>

<DT><PRE>
(seconds->time <I>x</I>)                                     ;procedure
</PRE><DD>

    Converts the exact or inexact real number <CODE><I>x</I></CODE>
    representing the number of seconds elapsed since some
    implementation dependent point in time into a time object.

<PRE>
        (seconds->time (+ 10 (time->seconds (current-time)))
        ==>  <I>a time object representing 10 seconds from now</I>
</PRE>

<DT><PRE>
(current-exception-handler)                           ;procedure
</PRE><DD>

    Returns the current exception handler.

<PRE>
        (current-exception-handler)  ==>  <I>a procedure</I>
</PRE>

<DT><PRE>
(with-exception-handler <I>handler</I> <I>thunk</I>)                ;procedure
</PRE><DD>

    Returns the result(s) of calling <CODE><I>thunk</I></CODE> with no
    arguments.  The <CODE><I>handler</I></CODE>, which must be a
    procedure, is installed as the current exception handler in the
    dynamic environment in effect during the call to
    <CODE><I>thunk</I></CODE>.

<PRE>
        (with-exception-handler
          list
          current-exception-handler)  ==>  <I>the procedure</I> list
</PRE>

<DT><PRE>
(raise <I>obj</I>)                                           ;procedure
</PRE><DD>

    Calls the current exception handler with <CODE><I>obj</I></CODE>
    as the single argument.  <CODE><I>obj</I></CODE> may be any Scheme
    object.

<PRE>
        (define (f n)
          (if (< n 0) (raise "negative arg") (sqrt n))))

        (define (g)
          (call-with-current-continuation
            (lambda (return)
              (with-exception-handler
                (lambda (exc)
                  (return
                    (if (string? exc)
                        (string-append "error: " exc)
                        "unknown error")))
                (lambda ()
                  (write (f 4.))
                  (write (f -1.))
                  (write (f 9.)))))))

        (g)  ==>  <I>writes</I> 2. <I>and returns</I> "error: negative arg"
</PRE>

<DT><PRE>
(join-timeout-exception? <I>obj</I>)                         ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is a "join timeout
    exception" object, otherwise returns <CODE>#f</CODE>.
    A join timeout exception is raised when <CODE>thread-join!</CODE> is
    called, the timeout is reached and no <CODE><I>timeout-val</I></CODE>
    is supplied.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true of
    <CODE><I>obj</I></CODE>, then <CODE>join-timeout-exception?</CODE>
    is false of <CODE><I>obj</I></CODE>.
-->

<DT><PRE>
(abandoned-mutex-exception? <I>obj</I>)                      ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is an "abandoned
    mutex exception" object, otherwise returns <CODE>#f</CODE>.
    An abandoned mutex exception is raised when the current thread locks a
    mutex that was owned by a thread which terminated
    (see <CODE>mutex-lock!</CODE> and <CODE>condition-variable-wait!</CODE>).
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true of
    <CODE><I>obj</I></CODE>, then <CODE>abandoned-mutex-exception?</CODE>
    is false of <CODE><I>obj</I></CODE>.
-->

<DT><PRE>
(started-thread-exception? <I>obj</I>)                       ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is a "started
    thread exception" object, otherwise returns <CODE>#f</CODE>.
    A started thread exception is raised when <CODE>thread-start!</CODE>
    is called and the target thread has already started or terminated.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true of
    <CODE><I>obj</I></CODE>, then <CODE>started-thread-exception?</CODE>
    is false of <CODE><I>obj</I></CODE>.
-->

<DT><PRE>
(terminated-thread-exception? <I>obj</I>)                    ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is a "terminated
    thread exception" object, otherwise returns <CODE>#f</CODE>.
    A terminated thread exception is raised when <CODE>thread-join!</CODE> is
    called and the target thread has terminated as a result of a call
    to <CODE>thread-terminate!</CODE>.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true of
    <CODE><I>obj</I></CODE>, then <CODE>terminated-thread-exception?</CODE>
    is false of <CODE><I>obj</I></CODE>.
-->

<DT><PRE>
(uncaught-exception? <I>obj</I>)                             ;procedure
</PRE><DD>

    Returns <CODE>#t</CODE> if <CODE><I>obj</I></CODE> is an "uncaught
    exception" object, otherwise returns <CODE>#f</CODE>.
    An uncaught exception is raised when <CODE>thread-join!</CODE> is
    called and the target thread has terminated because it raised an exception
    that called the initial exception handler of that thread.
<!--
    If any of the predicates listed in Section 3.2 of the R5RS is true of
    <CODE><I>obj</I></CODE>, then <CODE>uncaught-exception?</CODE>
    is false of <CODE><I>obj</I></CODE>.
-->

<DT><PRE>
(uncaught-exception-reason <I>exc</I>)                       ;procedure
</PRE><DD>

    <CODE><I>exc</I></CODE> must be an "uncaught exception" object.
    <CODE>uncaught-exception-reason</CODE> returns the exception
    object which was passed to the initial exception handler of that
    thread.

</DL>

<H1>Acknowledgements</H1>

Much of this design has been influenced by other thread systems.  Here
are the main contributions:
<UL>
<LI>Java: names, separation of thread creation and thread start
<LI>Erlang/Franz Common Lisp: thread advantage/quantum
<LI>Win32: abandoned mutexes
<LI>POSIX threads: names
<!--
<LI>QNX: priority decay
<LI>Modula-3 and Java: thread interrupts
-->
</UL>

<H1>Implementation</H1>

The implementation will be provided at a later time.  Due to the
non-portable nature of this SRFI the implementation will be for
a particular Scheme implementation, Gambit-C.

<H1>Copyright</H1>
Copyright (C) Marc Feeley (2000). All Rights Reserved. 
<P>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in it's implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.
<P>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.
<P>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


    <HR>
    <ADDRESS>Editor: <A href="mailto:srfi-editors@srfi.schemers.org">Mike Sperber</A></ADDRESS>
  </BODY>
</HTML>
